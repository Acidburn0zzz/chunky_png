{"name":"ChunkyPNG","tagline":"Read/write access to PNG images in pure Ruby.","body":"# Chunky PNG\r\n\r\nThis library can read and write PNG files. It is written in pure Ruby for\r\nmaximum portability. Let me rephrase: it does NOT require RMagick or any other\r\nmemory leaking image library.\r\n\r\n- Source code: http://github.com/wvanbergen/chunky_png/tree\r\n- RDoc: http://rdoc.info/gems/chunky_png/frames\r\n- Wiki: http://github.com/wvanbergen/chunky_png/wiki\r\n- Issue tracker: http://github.com/wvanbergen/chunky_png/issues\r\n\r\n## Features\r\n\r\n* Decodes any image that the PNG standard allows. This includes all standard\r\n  color modes, all bit depths and all transparency, interlacing and filtering options.\r\n* Encodes images supports all color modes (true color, grayscale and indexed)\r\n  and transparency for all these color modes. The best color mode will be\r\n  chosen automatically, based on the amount of used colors.\r\n* R/W access to the image's pixels.\r\n* R/W access to all image metadata that is stored in chunks.\r\n* Memory efficient (uses a Fixnum, i.e. 4 or 8 bytes of memory per pixel, depending\r\n  on the hardware)\r\n* Reasonably fast for Ruby standards, by only using integer math and a highly\r\n  optimized saving routine.\r\n* Interoperability with RMagick if you really have to.\r\n\r\nAlso, have a look at OilyPNG at http://github.com/wvanbergen/oily_png. OilyPNG is a \r\nmixin module that implements some of the ChunkyPNG algorithms in C, which \r\nprovides a massive speed boost to encoding and decoding.\r\n\r\n## Usage\r\n\r\n``` ruby\r\n  require 'chunky_png'\r\n\r\n  # Creating an image from scratch, save as an interlaced PNG\r\n  png = ChunkyPNG::Image.new(16, 16, ChunkyPNG::Color::TRANSPARENT)\r\n  png[1,1] = ChunkyPNG::Color.rgba(10, 20, 30, 128)\r\n  png[2,1] = ChunkyPNG::Color('black @ 0.5')\r\n  png.save('filename.png', :interlace => true)\r\n\r\n  # Compose images using alpha blending.\r\n  avatar = ChunkyPNG::Image.from_file('avatar.png')\r\n  badge  = ChunkyPNG::Image.from_file('no_ie_badge.png')\r\n  avatar.compose!(badge, 10, 10)\r\n  avatar.save('composited.png', :fast_rgba) # Force the fast saving routine.\r\n  \r\n  # Accessing metadata\r\n  image = ChunkyPNG::Image.from_file('with_metadata.png')\r\n  puts image.metadata['Title']\r\n  image.metadata['Author'] = 'Willem van Bergen'\r\n  image.save('with_metadata.png') # Overwrite file\r\n  \r\n  # Low level access to PNG chunks\r\n  png_stream = ChunkyPNG::Datastream.from_file('filename.png')\r\n  png_stream.each_chunk { |chunk| p chunk.type }\r\n```\r\n\r\nFor more information, see the project wiki on http://github.com/wvanbergen/chunky_png/wiki\r\nor the RDOC documentation on http://rdoc.info/gems/chunky_png/frames\r\n\r\n## Security warning\r\n\r\nChunkyPNG is vulnerable to decompression bombs, which means that ChunkyPNG is vulnerable to \r\nDOS attacks by running out of memory when loading a specifically crafted PNG file. Because \r\nof the pure-Ruby nature of the library it is very hard to fix this problem in the library \r\nitself.\r\n\r\nIn order to safely deal with untrusted images, you should make sure to do the image \r\nprocessing using ChunkyPNG in a separate process, e.g. by using fork or a background\r\nprocessing library.\r\n\r\n## About\r\n\r\nThe library is written by Willem van Bergen for Floorplanner.com, and released\r\nunder the MIT license (see LICENSE). Please contact me for questions or\r\nremarks. Patches are greatly appreciated!\r\n\r\nPlease check out the changelog on https://github.com/wvanbergen/chunky_png/wiki/Changelog\r\nto see what changed in all versions.\r\n\r\nP.S.: The name of this library is intentionally similar to Chunky Bacon and \r\nChunky GIF. Use Google if you want to know _why. :-)\r\n","google":"UA-37287278-1","note":"Don't delete this file! It's used internally to help with page regeneration."}